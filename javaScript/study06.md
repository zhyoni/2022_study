#### 💭 태그.classList
##### 태그.classList.add('클래스'); // 추가
##### 태그.classList.remove('클래스') // 제거
##### 태그.classList.replace('기존클래스','수정클래스') // 수정
##### 태그.classList.contains('클래스') // 클래스가 이 태그에 들어있는지 boolean으로 반환.

<br>

#### ♦️ const records = []; // const여도 배열은 push 가능. 대입하는 것은 불가능. 내부 수정 가능.

<br>

#### ♦️ 평균구하기
##### 💭 Array.prototype.reduce()
##### reduce((누적값, 현재값)=>{다음 누적값},초기값)
##### ex. [1,2,3,4] -> 1+2+3+4 / 4(배열의 총 길이)
```javascript
 //Array.prototype.reduce()
    // [1, 2, 3, 4].reduce((a, c) => { return a + c }) // return생략 가능
   { 
    [1, 2, 3, 4].reduce((a, c) => a + c, 0) 
    // reduce((누적값, 현재값)=>{다음 누적값},초기값)
    // 초기값이 처음 누적값
    // a: 0 c: 1  0 + 1 = 1
    // a: 1 c: 2  1 + 2 = 3
    // a: 3 c: 3  3 + 3 = 6
    // a: 6 c: 4  6 + 4 = 10
    // 10
    }

    {
      [1, 2, 3, 4].reduce((a, c) => a + c, 0) / [1,2,3,4].length
    // 2.5
    }

    {
    [1,2,3,4].reduce((a,c)=> a * c, 1);
    // 1 * c: 1 = 1
    // 1 * c: 2 = 2
    // 2 * c: 3 = 6
    // 6 * c: 4 = 24
    // 24
    }

    {
    ['철수','영희','현이','하나'].reduce((a,c,i)=>{a[i] = c; return a},{});
    // 배열을 객체리터럴로 변경
    // reduce((누적값,현재값,인덱스))
    // a:{}, c: "철수", i: 0    a{0:"철수"}
    // a:{0:"철수"}, c: "영희", i: 1  a{0:"철수",1:"영희"}   
    // a:{0:"철수",1:"영희"}, c: "현이", i: 2 {0:"철수",1:"영희",2:"현이"}
    // a:{0:"철수",1:"영희",2:"현이"}, c: "하나", i: 3 {0:"철수",1:"영희",2:"현이",3:"하나"}
    // {0:"철수",1:"영희",2:"현이",3:"하나"}
    }
    
    // 초기값을 넣지 않는 경우는 첫번째 값이 초기값이 된다. (항상 초기값을 확인해야한다.)
    // [1, 2, 3, 4].reduce((a, c) => a + c)
    // a: 1 c: 2  1 + 2 = 3
    // a: 3 c: 3  3 + 3 = 6
    // a: 6 c: 4  6 + 4 = 10
    // 10

```